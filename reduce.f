      subroutine reduce
c
c     ******************************************************************
c     *                                                                *
c     *      reduce is used to reduce the fully qualified move         *
c     *  generated by 'output' to the minimum notation required to     *
c     *  indicate a non-mbiguous move.  it tries several standard      *
c     *  short forms and uses subroutine 'test' to determine if the    *
c     *  shortened move is ambiguous.  for each ambiguous attempt,     *
c     *  additional information is added and 'test' tried again.       *
c     *  eventually a good short form will be found or the fully       *
c     *  qualified move will be used                                   *
c     *                                                                *
c     ******************************************************************
c
      implicit integer (a-z)
      logical englsh
      common /info/ from$, to$, type$, propc$, cappc$
      common /buffer/ text(80)
      common /red cm/ saver(30)
      common /typ ntn/ englsh
      common /chrset/ alpha(46)
      equivalence (blank,alpha(44)),(minus,alpha(38)),
     * (zero,alpha(27)),(nine,alpha(36)),(p,alpha(16)),
     * (x,alpha(24)),(slash,alpha(39)),(colon,alpha(46))
      common /return/ return
c
c------------------------------< initialize
c
      t1=to$
      f1=from$
      t2=type$
      p1=propc$
      c1=cappc$
      do 10 i=1,30
          saver(i)=text(i)
          if(text(i).eq.x .or. text(i).eq.minus) type=i
10    continue
      if(.not. englsh) go to 8000
      soff=1
      doff=1
      if(saver(4).ge.zero .and. saver(4).le.nine) soff=0
      dptr=type
      if(saver(type) .eq. x) dptr=type+2
      if(saver(dptr+2).ge.zero .and. saver(dptr+2).le.nine) doff=0
c
c------------------------------< if the move is a capture, off to
c------------------------------< some different checks.
c
      if(text(type) .eq. x) go to 1000
c
c------------------------------< *** n-b3 ***
c
      do 20 i=2,30
          if(text(i) .eq. minus) go to 30
          text(i)=blank
20    continue
30    continue
      if(doff .eq. 0) go to 40
      text(i+1)=blank
40    continue
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< *** n-kb3 ***
c
      do 50 i=1,30
          text(i)=saver(i)
50    continue
      do 60 i=2,30
          if(text(i) .eq. minus) go to 70
          text(i)=blank
60    continue
70    continue
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< *** n/1-b3 ***
c
75    continue
      if(doff .ne. 0) text(3)=blank
      do 71 i=1,27
          text(31-i)=text(29-i)
71    continue
      text(2)=slash
      text(3)=saver(soff+4)
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< *** n/r-be ***
c
      text(3)=saver(3+soff)
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< it's still ambiguous.  fully qualify
c------------------------------< it and give up on simplicity
c
999   continue
      do 80 i=1,30
          text(i)=saver(i)
80    continue
      to$=t1
      from$=f1
      propc$=p1
      cappc$=c1
      type$=t2
      return
c
c------------------------------< the move is a capture, process the
c------------------------------< three cases of 1) piece captures piece,
c------------------------------< 2) piece captures pawn and 3) pawn
c------------------------------< captures piece.
c
c
c------------------------------< ** nxb ***
c
1000  continue
      do 1010 i=2,30
          if(text(i) .eq. x) go to 1020
          text(i)=blank
1010  continue
1020  i=i+2
      l=i+2+doff
      do 1030 j=i,l
          text(j)=blank
1030  continue
      call test
      if(return .ne. 0) go to 9999
      if(saver(1) .eq. p) go to 2000
      if(saver(type+1) .ne. p) go to 3000
c
c------------------------------< the move is a capture.  the captured
c------------------------------< piece is a pawn.
c
c------------------------------< *** nxbp ***
c
      do 1050 i=1,27
          text(31-i)=text(30-i)
1050  continue
      text(3)=saver(type+3+doff)
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< *** nxkbp ***
c
      if(doff .eq. 0) go to 1070
      do 1060 i=1,27
          text(31-i)=text(30-i)
1060  continue
      text(3)=saver(type+3)
      call test
      if(return .ne. 0) go to 9999
1070  continue
c
c------------------------------< *** nxp/3 ***
c
      text(3)=text(doff+4)
      text(4)=slash
      text(5)=saver(type+doff+4)
      call test
      if(return .ne. 0) go to 9999
      text(4)=blank
      text(5)=blank
      go to 3000
c
c------------------------------< the move is a capture.  the capturing
c------------------------------< piece is a pawn.
c
c------------------------------< *** npxp ***
c
2000  continue
      do 2010 i=1,29
          text(31-i)=text(30-i)
2010  continue
      text(1)=saver(soff+3)
      call test
      if(return .ne. 0) go to 9999
      go to 999
c
c------------------------------< the move is a capture.  the capturing
c------------------------------< and captured pieces are not pawns.
c
c------------------------------< *** n/1xb ***
c
3000  continue
      do 3010 i=1,27
          text(31-i)=text(29-i)
3010  continue
      text(2)=slash
      text(3)=saver(soff+4)
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< *** n/rxb ***
c
      text(3)=saver(soff+3)
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< *** nxb/1 ***
c
      text(2)=text(4)
      text(3)=text(5)
      text(4)=slash
      text(5)=saver(type+doff+4)
      call test
      if(return .ne. 0) go to 9999
c
c------------------------------< *** nxb/r ***
c
      text(5)=saver(type+doff+3)
      call test
      if(return .ne. 0) go to 9999
      go to 9999
c
c------------------------------< algebraic notation, try *** e4 ***
c
8000  continue
      do 8010 i=1,4
          text(i)=blank
8010  continue
      if(saver(4) .eq. colon) text(7)=colon
      if(saver(1) .ne. p) go to 8020
          call test
          if(return .ne. 0) go to 9999
8020  continue
c
c------------------------------< *** pe4 ***
c
      do 8030 i=1,30
          text(i)=saver(i)
8030  continue
      do 8040 i=2,4
          text(i)=blank
8040  continue
      call test
      if(return .ne. 0) go to 9999
      go to 999
c
c------------------------------< simplification completed. return
c
9999  continue
      to$=t1
      from$=f1
      propc$=p1
      cappc$=c1
      type$=t2
      return
      end



